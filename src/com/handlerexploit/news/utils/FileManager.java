/*
 *  Copyright (c) 2011 Daniel Huckaby
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.handlerexploit.news.utils;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InvalidClassException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import android.content.Context;
import android.os.Environment;
import android.util.Log;

/**
 * Provider for the application's persistent cache of content
 */
public class FileManager<T extends Serializable> {
    
    private static final String TAG = FileManager.class.getSimpleName();
    private String mCacheDirectory;
    private int mTtlMinutes = 7200; 
    
    /**
     * @param directory The directory that cache should be stored
     */
    protected FileManager(String directory) {
        mCacheDirectory = directory;
        new File(mCacheDirectory).mkdirs();
    }
    
    /**
     * Using the Context provided the default directory is set to the internal directory specified for 
     * cache by the operating system for this specific application. We are NOT using Context.getCacheDir()
     * @param context Application context
     */
    public FileManager(Context context) {
        this(Environment.getDataDirectory().getPath() + "/data/" + context.getPackageName() + "/cache/");
    }
    
    /**
     * Default time to load is 7,200 minutes, or five days.
     * 
     * @param minutes Time to load in minutes
     */
    public void setGlobalTtl(int minutes) {
        mTtlMinutes = minutes;
    }
    
    /**
     * @param key Requested filename, this will be obfuscated
     * @return Object from file storage if available, else returns null
     */
    public Object get(String key) {
        File currentFile = new File(mCacheDirectory + computeMD5Sum(key));
        if (!currentFile.exists()) return null;
        
        FileInputStream fileInputStreamCache = null;
        ObjectInput objectInputCache = null;
        Object object = null;

        long cacheExpriationInMillis = mTtlMinutes * 60 * 1000l;
        long timeOfExpirationInMillis = currentFile.lastModified() + cacheExpriationInMillis;

        if (System.currentTimeMillis() < timeOfExpirationInMillis) {
            try {
                fileInputStreamCache = new FileInputStream(currentFile);
                objectInputCache = new ObjectInputStream(fileInputStreamCache);
                object = objectInputCache.readObject();
                
            } catch (InvalidClassException e) {
                if (currentFile.delete()) {
                    Log.d(TAG, "Invalid file, file was deleted", e);
                } else {
                    Log.d(TAG, "Invalid file, error deleting file", e);
                }
                object = null;
            } catch (IOException e) {
                Log.d(TAG, "Error loading file from cache", e);
            } catch (ClassNotFoundException e) {
                Log.d(TAG, "Error loading file from cache", e);
            } catch (OutOfMemoryError e) {
                Log.d(TAG, "Error loading file from cache", e);
            } finally {
                try {
                    if (fileInputStreamCache != null) {
                        fileInputStreamCache.close();
                        fileInputStreamCache = null;
                    }
                    if (objectInputCache != null) {
                        objectInputCache.close();
                        objectInputCache = null;
                    }
                    currentFile = null;
                } catch (IOException e) {
                    Log.d(TAG, "Error closing output streams", e);
                }
            }
        }

        if (currentFile != null) {
            currentFile = null;
        }
        
        return object;
    }

    /**
     * @param key Filename, this will be obfuscated
     * @param object Serial file to be saved to file storage
     * @return true if everything went smoothly, false if something went wrong
     */
    public boolean put(String key, T object) {
        File currentFile = new File(mCacheDirectory + computeMD5Sum(key));
        File temporaryFile = new File(currentFile.getAbsolutePath() + ".tmp");

        FileOutputStream fileOutputStreamCache = null;
        ObjectOutput objectOutputCache = null;

        if (temporaryFile.exists()) {
            temporaryFile.delete();
        }

        if (currentFile.exists()) {
            currentFile.delete();
        }
        
        try {
            fileOutputStreamCache = new FileOutputStream(temporaryFile);
            objectOutputCache = new ObjectOutputStream(fileOutputStreamCache);
            objectOutputCache.writeObject(object);

            objectOutputCache.close();
            objectOutputCache = null;

            fileOutputStreamCache.close();
            fileOutputStreamCache = null;
            
            return temporaryFile.renameTo(currentFile);
        } catch (FileNotFoundException e) {
            Log.d(TAG, "Error inserting file into cache", e);
        } catch (IOException e) {
            Log.d(TAG, "Error inserting file into cache", e);
        } catch (OutOfMemoryError e) {
            Log.d(TAG, "Error inserting file into cache", e);
        } finally {
            try {
                if (objectOutputCache != null) {
                    objectOutputCache.close();
                    objectOutputCache = null;
                }
                if (fileOutputStreamCache != null) {
                    fileOutputStreamCache.close();
                    fileOutputStreamCache = null;
                }
            } catch (IOException e) {
                Log.d(TAG, "Error closing output streams", e);
            }

            currentFile = null;
            temporaryFile = null;
        }
        return false;
    }

    private String computeMD5Sum(String input) {
        if (input == null) {
            throw new IllegalArgumentException("Input cannot be null");
        } else {
            StringBuffer stringBuffer = new StringBuffer();
            MessageDigest messageDigest = null;
            try {
                messageDigest = MessageDigest.getInstance("MD5");
            } catch (NoSuchAlgorithmException e) {
                Log.d(TAG, "No MD5 algorithm found, defaulting to a basic url encode", e);
            }
            if (messageDigest == null) {
                try {
                    return URLEncoder.encode(input, "UTF-8");
                } catch (UnsupportedEncodingException e) {
                    Log.d(TAG, "Something went terribly wrong", e);
                    return null;
                }
            } else {
                byte [] raw = messageDigest.digest(input.getBytes());
                for (int i = 0; i < raw.length; i++) {
                    int j = (int) raw[i];
                    if (j < 0) {
                        j = (Math.abs(j) - 1) ^ 255;
                    }
                    String block = toHex(j >>> 4) + toHex(j & 15);
                    stringBuffer.append(block);
                }
                return stringBuffer.toString();
            }
        }
    }
    
    private String toHex(int s) {
        if (s < 10) {
           return new StringBuffer().append((char)('0' + s)).toString();
        } else {
           return new StringBuffer().append((char)('A' + (s - 10))).toString();
        }
    }
}