/*
 *  Copyright (c) 2011 Daniel Huckaby
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.handlerexploit.news.utils;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;
import java.net.UnknownHostException;

import com.handlerexploit.news.data.models.SerialBitmap;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.support.v4.util.LruCache;
import android.util.Log;

public class BitmapLruCache extends LruCache<String, Bitmap> {
    
    private static final String TAG = BitmapLruCache.class.getSimpleName();
    private static final int FOUR_MEGABYTES = 4 * 1024 * 1024;
    private FileManager<SerialBitmap> mFileManager;

    public BitmapLruCache(Context context) {
        super(FOUR_MEGABYTES);
        mFileManager = new FileManager<SerialBitmap>(context);
    }
    
    @Override
    protected int sizeOf(String key, Bitmap value) {
        return value.getRowBytes() * value.getHeight();
    }
    
    @Override
    protected Bitmap create(String source) {
        SerialBitmap cachedBitmap = (SerialBitmap) mFileManager.get(source);
        return cachedBitmap != null ? cachedBitmap.getBitmap() : null;
    }
    
    public void put(String source, Bitmap value, boolean useHardCache) {
        if (useHardCache) {
            mFileManager.put(source, new SerialBitmap(value));
        }
        put(source, value);
    }
    
    /**
     * Convenience method to retrieve a bitmap image from a URL over the
     * network. The built-in methods do not seem to work, as they return a
     * FileNotFound exception.
     * 
     * Note that this does not perform any threading -- it blocks the call while
     * retrieving the data.
     * 
     * @param url
     *            The URL to read the bitmap from.
     * @return A Bitmap image or null if an error occurs.
     */
    public static Bitmap readBitmapFromNetwork(String url) {
        InputStream inputStream = null;
        BufferedInputStream bufferedInputStream = null;
        Bitmap bitmap = null;
        
        try {
            URLConnection conn = new URL(url).openConnection();
            conn.connect();
            inputStream = conn.getInputStream();
            bufferedInputStream = new BufferedInputStream(inputStream, 8192);
            bitmap = BitmapFactory.decodeStream(bufferedInputStream);
        } catch (OutOfMemoryError e) {
            Log.d(TAG, "Ran out of memory.", e);
        } catch (Throwable e) {
            if (!e.getClass().equals(UnknownHostException.class)) {
                Log.d(TAG, "Could not get remote image : " + e.getClass().getSimpleName(), e);
            }
        } finally {
            try {
                if (inputStream != null) {
                    inputStream.close();
                }
                if (bufferedInputStream != null) {
                    bufferedInputStream.close();
                }
            } catch (IOException e) {
                Log.d(TAG, "Error closing stream.", e);
            }
        }
        return bitmap;
    }
}